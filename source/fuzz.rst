Fuzz方法
==================================================

Fuzz是一种侧重于发现软件安全漏洞的方法。典型地Fuzz测试过程是通过自动的或半自动的方法，反复驱动目标软件运行，并为其提供特别构造的输入数据，同时监控软件运行的异常，进而根据异常结果及输入数据查找软件的安全漏洞。

白盒fuzz
--------------------------------------------------
白盒fuzz会先对应用进行分析，以确保其创建的输入能在应用程序中发现崩溃。 但是一个应用程序一般有有许多分支，然后形成许多可能的执行流。

不过如果有了很大的测试空间，就有可能创建几乎无限的输入来遍历所有的执行流。一般白盒fuzz会试图创造在更少的输入的同时来尽量覆盖更多的路径。目前也有一些研究取得了成果，比如CRAX[1-2]就用符号执行的方式完成了一个白盒浏览器漏洞fuzz工具。

但是由于执行流程过多和复杂的约束，白盒fuzz在应用程序中可能并不精确。 此外，白盒fuzz分析应用程序需要比较多的时间，所以浏览器fuzz一般仍以黑盒fuzz为主。

符号执行
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
符号执行是白盒fuzz的一个常用技术。其关键思想就是，把输入变为符号值，那么程序计算的输出值就是一个符号输入值的函数。这个符号化的过程在文章[1-9]中已有简要阐述，简而言之，就是一个程序执行的路径通常是true和false条件的序列，这些条件是在分支语句处产生的。

符号执行要解决的问题主要是路径选择、约束求解、内存建模、处理并发这几个方面。

黑盒fuzz
--------------------------------------------------
黑盒fuzz是一个有效和找到漏洞的简单方法，和白盒不同的是，黑盒fuzz将直接产生输入然后尝试找到结果，而黑盒fuzz又可以更细分为Genertion-Based Fuzz和Mutation-Based Fuzz或者混合型的Hybrid Fuzz。 

Mutation-Based Fuzz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
在Mutation-Based Fuzz中，一般会提供一个到多个有效的样本。
简单的fuzz会对这些样本进行字节级或者字符级别的替换、删除、增加、重复。相对来说，这种fuzz方式比较好实现，而且几乎不需要任何的先验知识，只要有一个或几个构造好的样本即可。但是相对来说，这种fuzz方式也更依赖于给定的样本，如果样本触发的代码覆盖率不高，那么这种方式的覆盖率一般也不会高。

Genertion-Based Fuzz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
相对Mutation-Based Fuzz，直接生成样本的方式覆盖率会更高，但是相对的，这种方式也需要更多的种子样本。对样本的依赖性也更强。

Hybrid Fuzz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
考虑到Genertion-Based和Mutation-Based的优缺点，那么另一种方式就是结合两种模式共同进行fuzz，生成随机样本之后再进行相应的变换，以获得更好的fuzz效率。
